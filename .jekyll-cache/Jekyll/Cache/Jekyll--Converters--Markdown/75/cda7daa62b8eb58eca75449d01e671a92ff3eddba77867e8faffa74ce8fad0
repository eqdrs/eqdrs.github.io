I"b7<p>A an√°lise l√©xica √© a primeira fase do processo de compila√ß√£o de um programa, respons√°vel por fazer a leitura do c√≥digo fonte, caractere a caractere, especificando os tokens e lexemas da linguagem. Neste post, iremos implementar e testar um analisador l√©xico para uma linguagem inspirada em C. E faremos isso usando o Flex!</p>

<p>O <a href="https://www.gnu.org/software/flex/">Flex</a> (Fast Lexical Analyzer Generator) √© uma ferramenta gratuita e open-source para gera√ß√£o de analisadores l√©xicos. Ela foi escrita em C, por volta de 1987, pelo Professor <a href="https://en.wikipedia.org/wiki/Vern_Paxson">Vern Paxson</a>.</p>

<h5 id="instalando-o-flex">Instalando o Flex</h5>
<p />

<p>Para instalar o Flex no Ubuntu, basta abrir o seu terminal (Ctrl + Alt + T) e executar os comandos abaixo:</p>

<pre>
sudo apt-get update
sudo apt-get install flex
</pre>

<p>Pronto! J√° podemos utilizar os recursos do Flex!</p>

<h5 id="definindo-uma-conven√ß√£o-l√©xica-para-a-linguagem">Definindo uma conven√ß√£o l√©xica para a linguagem</h5>
<p />

<p>Nossa linguagem ser√° simples e procedimental, um subconjunto inspirado na linguagem C, que inclui somente vari√°veis inteiras, array de inteiros, fun√ß√µes, condi√ß√£o, e repeti√ß√£o. A linguagem seguir√° as conven√ß√µes definidas a seguir.</p>

<ul>
  <li>Na implementa√ß√£o, iremos considerar as seguintes classes de tokens na linguagem:</li>
</ul>

<pre>
  <b>ID</b>      Identificador
  <b>NUM</b>     Literal decimal (inteiro)
  <b>KEY</b>     Palavra-chave
  <b>SYM</b>     S√≠mbolos l√©xicos
  <b>ERROR</b>   Lexema do primeiro erro encontrado
</pre>

<ul>
  <li>As palavras revervadas (keywords) ser√£o as seguintes:</li>
</ul>

<pre>
  <b>else   if   int   return   void   while</b>
</pre>

<p>Elas <strong>n√£o</strong> poder√£o ser usadas como nomes de vari√°veis/fun√ß√µes, e devem ser escritas em min√∫sculo.</p>

<ul>
  <li>Os s√≠mbolos especiais ser√£o:</li>
</ul>

<pre>
  <b>!  &amp;&amp;  ||   +  -  *  /  &lt;  &lt;=  &gt;  &gt;=  ==  !=  =  ;  ,  (  )  [  ]  {  }  /*  */</b>
</pre>

<ul>
  <li>Os outros lexemas s√£o o ID e NUM, definidos pelas express√µes regulares abaixo:</li>
</ul>

<pre>
  <b>ID</b> = letter (letter | digit)*
  <b>NUM</b> = digit digit*
  <b>letter</b> = a | .. | z | A | .. | Z
  <b>digit</b> = 0 | .. | 9
</pre>

<ul>
  <li>
    <p>Haver√° distin√ß√£o entre letras em mai√∫sculo e min√∫sculo.</p>
  </li>
  <li>
    <p>Os espa√ßos em branco consistem em caracter branco (‚Äò ‚Äò), quebra-de-linha (‚Äò\n‚Äô), e tabs (‚Äò\t‚Äô). Eles dever√£o ser ignorados, exceto quando for necess√°rio separar os ID‚Äôs e NUM‚Äôs, e palavras reservadas.</p>
  </li>
  <li>
    <p>Coment√°rios ser√£o escritos da mesma forma que na linguagem C, usando a nota√ß√£o /* ‚Ä¶  */. Poder√£o ser inseridos em qualquer parte do c√≥digo onde √© permitido colocar espa√ßos em branco, isto √©, coment√°rios <strong>n√£o</strong> poder√£o ser inseridos dentro de tokens, e podem incluir mais de uma linha.</p>
  </li>
</ul>

<h5 id="desenvolvendo-o-arquivo-flex">Desenvolvendo o arquivo Flex</h5>
<p />

<p>O c√≥digo flex √© dividido em tr√™s se√ß√µes:</p>

<pre>
  <b>defini√ß√µes</b>
  %%
  <b>regras</b>
  %%
  <b>c√≥digo do usu√°rio</b>
</pre>

<p>Para a linguagem que definimos, criaremos um arquivo chamado <code class="highlighter-rouge">lexico.l</code> com o c√≥digo abaixo. Notem que ele √© dividido em tr√™s se√ß√µes, onde, na se√ß√£o intermedi√°ria, definimos a a√ß√£o a ser tomada para cada <em>pattern</em>.</p>

<pre><code class="language-l">digit[0-9]
letter[a-zA-Z]
ID[a-zA-Z][a-zA-Z0-9]*
WHITESPACE[ ]
quebra[\n]
TAB[\t]

%{
    #define YY_DECL extern "C" int yylex()
    #include&lt;string&gt;
    #include&lt;iostream&gt;
    using namespace std;
    FILE *out ;
	int linha;
%}
%option yylineno
%x COMMENT

%%

{quebra}

"/*" { linha=yylineno; BEGIN(COMMENT); }

&lt;COMMENT&gt;"*/" { BEGIN(INITIAL); }

&lt;COMMENT&gt;(.|\n);

&lt;COMMENT&gt;&lt;&lt;EOF&gt;&gt; {fprintf(out,"(%d,ERROR,\"/*\")\n",linha); return 0;}

else|if|int|return|void|while {fprintf(out,"(%d,KEY,\"%s\")\n",yylineno ,yytext);} 

"+"|"-"|"*"|"/"|"&lt;"|"&lt;="|"&gt;"|"&gt;="|"=="|"!="|"="|";"|","|"("|")"|"["|"]"|"{"|"}" {fprintf(out,"(%d,SYM,\"%s\")\n",yylineno,yytext);}

{WHITESPACE}+|{quebra}|{TAB}+
 
{digit}+ {fprintf(out,"(%d,NUM,\"%s\")\n",yylineno,yytext);}

{digit}+{ID}+ {fprintf(out,"(%d,ERROR,\"%s\")\n",yylineno,yytext); return 0;}

{ID}+ {fprintf(out,"(%d,ID,\"%s\")\n",yylineno,yytext);}

. {fprintf(out,"(%d,ERROR,\"%s\")\n",yylineno,yytext); return 0;}

%%

int yywrap();

int main(int argc, char *argv[]){
    FILE *arquivo = fopen(argv[1],"r");
    if (!arquivo) {
      cout &lt;&lt; "Arquivo inexistente" &lt;&lt; endl;
      return -1;
    }
    yyin = arquivo;
    out = fopen(argv[2],"w");
    yylex();
    return 0;
}

int yywrap(){
    return 1;
}
</code></pre>

<h5 id="gerando-o-arquivo-lexyyc">Gerando o arquivo lex.yy.c</h5>
<p />

<p>Ap√≥s criarmos o arquivo <code class="highlighter-rouge">lexico.l</code> com as regras para o nosso analisador l√©xico, vamos gerar um arquivo chamado <code class="highlighter-rouge">lex.yy.c</code>, usando o Flex. Para isso, basta executar o comando abaixo no terminal:</p>

<pre>
flex lexico.l
</pre>

<p>Isso ir√° criar o <code class="highlighter-rouge">lex.yy.c</code> no mesmo diret√≥rio. Esse arquivo cont√©m uma fun√ß√£o chamada <code class="highlighter-rouge">yylex()</code>, que retorna 1 sempre que uma express√£o especificada for encontrada no arquivo de entrada, e 0 quando o final do arquivo for atingido. Cada chamada √† fun√ß√£o <code class="highlighter-rouge">yylex()</code> analisa um token; quando a fun√ß√£o √© chamada novamente, ela come√ßa de onde parou.</p>

<h5 id="gerando-o-execut√°vel">Gerando o execut√°vel</h5>

<p>Para gerar o execut√°vel, vamos compilar o arquivo gerado pelo Flex atrav√©s do comando:</p>

<pre>
g++ lex.yy.c -lfl -o lexico
</pre>

<h5 id="testando-nosso-analisador-l√©xico">Testando nosso analisador l√©xico</h5>
<p />

<p>Agora vamos testar nosso analisador l√©xico! Para isto, iremos criar um arquivo de exemplo chamado <code class="highlighter-rouge">main.c</code>, que ir√° conter o nosso programa-fonte:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="cm">/* main.c */</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="cm">/* Testando
              coment√°rio
              em bloco. */</span>
  <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Para iniciar a an√°lise l√©xica, basta executar o seguinte comando no terminal:</p>

<pre>
./lexico main.c main.lex
</pre>

<p>Com isso, ser√° gerado um arquivo chamado <code class="highlighter-rouge">main.lex</code> no mesmo diret√≥rio, contendo o resultado da an√°lise l√©xica do nosso c√≥digo-fonte:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">KEY</span><span class="p">,</span><span class="s">"void"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">ID</span><span class="p">,</span><span class="s">"main"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"("</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">KEY</span><span class="p">,</span><span class="s">"void"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">")"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"{"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">KEY</span><span class="p">,</span><span class="s">"int"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">ID</span><span class="p">,</span><span class="s">"a"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">";"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">ID</span><span class="p">,</span><span class="s">"a"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"="</span><span class="p">)</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">NUM</span><span class="p">,</span><span class="s">"10"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">";"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">KEY</span><span class="p">,</span><span class="s">"if"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"("</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">ID</span><span class="p">,</span><span class="s">"a"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"&gt;"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">NUM</span><span class="p">,</span><span class="s">"9"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">")"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"{"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">ID</span><span class="p">,</span><span class="s">"a"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"="</span><span class="p">)</span>
<span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"("</span><span class="p">)</span>
<span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">NUM</span><span class="p">,</span><span class="s">"4"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"+"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">NUM</span><span class="p">,</span><span class="s">"5"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">")"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"*"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">NUM</span><span class="p">,</span><span class="s">"3"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">";"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"}"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="n">SYM</span><span class="p">,</span><span class="s">"}"</span><span class="p">)</span></code></pre></figure>

<p>Podemos ver que o nosso analisador l√©xico identificou todos os tokens e suas respectivas classes, como era esperado! Al√©m disso, todos os coment√°rios, tabs e quebras de linha foram ignorados, como tamb√©m j√° prev√≠amos. \o/</p>

<p>No processo de compila√ß√£o de um programa, essas informa√ß√µes s√£o enviadas posteriormente para o analisador sint√°tico, respons√°vel por gerar uma estrutura de dados a partir do c√≥digo-fonte e verificar se ela est√° de acordo com a gram√°tica que foi definida para a linguagem. Mas isso j√° √© assunto para um pr√≥ximo post!</p>

<p>Caso queira se aprofundar ainda mais nessa √°rea, recomendo o <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/about">curso de compiladores da Stanford</a> (em ingl√™s).</p>

<p>Obrigado a tod@s, e at√© mais! üòä</p>

:ET